<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>code.core.server2020 API documentation</title>
<meta name="description" content="Author: Jonathan Rotter â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>code.core.server2020</code></h1>
</header>
<section id="section-intro">
<p>Author: Jonathan Rotter</p>
<p>Server code</p>
<p>To be run on server pi. It is required (probably) that
it is started before motor2020++.py or surface2020.py</p>
<p>Once it is running it does not need to be restarted
even if its clients restart or lose connection</p>
<p>Required 3rd-party libraries:
<code>autobahn</code>
<code>twisted</code></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3.4

&#39;&#39;&#39;Author: Jonathan Rotter

Server code

To be run on server pi. It is required (probably) that
it is started before motor2020++.py or surface2020.py

Once it is running it does not need to be restarted
even if its clients restart or lose connection

Required 3rd-party libraries:
`autobahn`
`twisted`
&#39;&#39;&#39;

# Check if the version of python is 3.x
import sys
if sys.version[0] != &#39;3&#39;:
    # Stop running if the version is python 2.x
    raise Exception(&#39;This is Python3 code&#39;)

# importing the necessary objects
# autobahn does websocket stuff, but relies on twisted
from autobahn.twisted.websocket import \
    WebSocketServerProtocol, WebSocketServerFactory

# twisted does asynchronous code execution needed for websockets
from twisted.python import log
from twisted.internet import task, reactor

IP = &#39;127.0.0.1&#39;
&#39;&#39;&#39;ip is localhost, does not need to be changed&#39;&#39;&#39;

PORT = 8008
&#39;&#39;&#39;Make sure the port set here and in webSocketClient are the same&#39;&#39;&#39;


class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Describes how the websocket server should act
    with one connection

    How to connect to it in JavaScript
    ws = new WebSocket(&#39;ws://localhost:8008/motor&#39;)
    ws = new WebSocket(&#39;ws://localhost:8008/surface&#39;)
    &#39;&#39;&#39;

    def onConnect(self, request):
        &#39;&#39;&#39;
        Called by the server factory when
        a client connects.
        The path is found in `request.path`
        and is used for the clients to specify
        whether they are motor2020 or surface2020
        &#39;&#39;&#39;

        print(request.path)
        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.factory.register(self, clientTypeRequest)

    def onOpen(self):
        &#39;&#39;&#39;
        Called by the server factory.
        Only prints debug info
        &#39;&#39;&#39;
        print(&#39;WebSocket connection open&#39;)

    def onClose(self, wasClean, code, reason):
        &#39;&#39;&#39;
        Called by the server factory when
        a client disconnects
        &#39;&#39;&#39;
        print(&#39;WebSocket connection closed &amp; deregistering: {0}&#39;.format(reason))

        # tell the factory that this connection is dead
        self.factory.unregister(self)

    def onMessage(self, msg, isBinary):
        &#39;&#39;&#39;
        Called by the server factory when
        the client send a message.
        The message is then sent to all
        other connected clients
        &#39;&#39;&#39;

        # tell the factory to broadcast the received message
        # to all other connected clients
        self.factory.broadcast(self, msg, isBinary)


class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url):
        &#39;&#39;&#39;
        Initializes the class

        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
        &#39;&#39;&#39;
        WebSocketServerFactory.__init__(self, url)

        # init fields
        self.motorConnection = None
        self.miniMotorConnection = None
        self.surfaceConnection = None

    def register(self, client, clientTypeRequest):
        &#39;&#39;&#39;
        Called in `ServerProtocol.onConnect`
        Remembers a connecting client so that
        later data can be received from or broadcast to the client

        Args:
            client (ServerProtocol): A instance representing the connection
            clientTypeRequest (str): Whether the client is surface or motor pi
        &#39;&#39;&#39;

        if clientTypeRequest == &#39;surface&#39;:
            self.surfaceConnection = client  # surface sends joystick data

        elif clientTypeRequest == &#39;motor&#39;:
            self.motorConnection = client  # motor receives joystick data

        elif clientTypeRequest == &#39;miniROV&#39;:
            self.miniMotorConnection = client  # mini-rov recives joystick data

        else:
            print(&#39;Bad client type received: {}&#39;.format(clientTypeRequest))
            # end the connection because the client&#39;s type is not recognized
            # the type the client is is specified by the path in the url
            client._closeConnection()
            # find some better way to end the connection; unclean closing

    def unregister(self, client):
        &#39;&#39;&#39;
        Called in `ServerProtocol.onClose`
        Removes a client from the list of clients
        as it is disconnecting from the server

        Args:
            client (ServerProtocol): The connection to remove
        &#39;&#39;&#39;

        if self.surfaceConnection == client:
            self.surfaceConnection = None

        elif self.motorConnection == client:
            self.motorConnection = None

        elif self.miniMotorConnection == client:
            self.miniMotorConnection = None

        else:
            print(&#39;Unknown client: {}&#39;.format(client))

    def broadcast(self, client, msg, isBinary):
        &#39;&#39;&#39;
        Broadcasts data to other connections.
        This is how surface pi sends the
        state of the XBox controller to motor pi

        Arg:
            client (ServerProtocol): The source of the message
            msg (str or bytes): The message to relay
            isBinary (bool): If the msg is already encoded
        &#39;&#39;&#39;

        # only surface pi is supposed to send data
        if self.surfaceConnection == client:

            # broadcast to motor2020
            if self.motorConnection:
                self.motorConnection.sendMessage(msg)

            # broadcast to miniROV
            if self.miniMotorConnection:
                self.miniMotorConnection.sendMessage(msg)

        # debug messages
        elif self.motorConnection == client:
            print(&#39;Motor Pi isn\&#39;t supposed to send stuff&#39;)

        elif self.miniMotorConnection == client:
            print(&#39;Mini ROV isn\&#39;t supposed to send stuff&#39;)


if __name__ == &#39;__main__&#39;:
    # display debug information to stdout for now
    log.startLogging(sys.stdout)  # TODO: replace with log file (maybe)

    # Setup server factory
    server = ServerFactory(u&#39;ws://{}:{}&#39;.format(IP, PORT))
    server.protocol = ServerProtocol

    # setup listening server
    reactor.listenTCP(PORT, server)

    try:
        # start listening for and handling connections
        reactor.run()
    finally:
        pass
        # if logs are sent to a file instead of stdout
        # the file should be closed here with f.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="code.core.server2020.IP"><code class="name">var <span class="ident">IP</span></code></dt>
<dd>
<section class="desc"><p>ip is localhost, does not need to be changed</p></section>
</dd>
<dt id="code.core.server2020.PORT"><code class="name">var <span class="ident">PORT</span></code></dt>
<dd>
<section class="desc"><p>Make sure the port set here and in webSocketClient are the same</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="code.core.server2020.ServerFactory"><code class="flex name class">
<span>class <span class="ident">ServerFactory</span></span>
<span>(</span><span>url)</span>
</code></dt>
<dd>
<section class="desc"><p>Keeps track of all connections and relays data to other clients</p>
<p>Initializes the class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>has to be in the format of "ws://127.0.0.1:8008"</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerFactory(WebSocketServerFactory):
    &#39;&#39;&#39;
    Keeps track of all connections and relays data to other clients
    &#39;&#39;&#39;

    def __init__(self, url):
        &#39;&#39;&#39;
        Initializes the class

        Args:
            url (str): has to be in the format of &#34;ws://127.0.0.1:8008&#34;
        &#39;&#39;&#39;
        WebSocketServerFactory.__init__(self, url)

        # init fields
        self.motorConnection = None
        self.miniMotorConnection = None
        self.surfaceConnection = None

    def register(self, client, clientTypeRequest):
        &#39;&#39;&#39;
        Called in `ServerProtocol.onConnect`
        Remembers a connecting client so that
        later data can be received from or broadcast to the client

        Args:
            client (ServerProtocol): A instance representing the connection
            clientTypeRequest (str): Whether the client is surface or motor pi
        &#39;&#39;&#39;

        if clientTypeRequest == &#39;surface&#39;:
            self.surfaceConnection = client  # surface sends joystick data

        elif clientTypeRequest == &#39;motor&#39;:
            self.motorConnection = client  # motor receives joystick data

        elif clientTypeRequest == &#39;miniROV&#39;:
            self.miniMotorConnection = client  # mini-rov recives joystick data

        else:
            print(&#39;Bad client type received: {}&#39;.format(clientTypeRequest))
            # end the connection because the client&#39;s type is not recognized
            # the type the client is is specified by the path in the url
            client._closeConnection()
            # find some better way to end the connection; unclean closing

    def unregister(self, client):
        &#39;&#39;&#39;
        Called in `ServerProtocol.onClose`
        Removes a client from the list of clients
        as it is disconnecting from the server

        Args:
            client (ServerProtocol): The connection to remove
        &#39;&#39;&#39;

        if self.surfaceConnection == client:
            self.surfaceConnection = None

        elif self.motorConnection == client:
            self.motorConnection = None

        elif self.miniMotorConnection == client:
            self.miniMotorConnection = None

        else:
            print(&#39;Unknown client: {}&#39;.format(client))

    def broadcast(self, client, msg, isBinary):
        &#39;&#39;&#39;
        Broadcasts data to other connections.
        This is how surface pi sends the
        state of the XBox controller to motor pi

        Arg:
            client (ServerProtocol): The source of the message
            msg (str or bytes): The message to relay
            isBinary (bool): If the msg is already encoded
        &#39;&#39;&#39;

        # only surface pi is supposed to send data
        if self.surfaceConnection == client:

            # broadcast to motor2020
            if self.motorConnection:
                self.motorConnection.sendMessage(msg)

            # broadcast to miniROV
            if self.miniMotorConnection:
                self.miniMotorConnection.sendMessage(msg)

        # debug messages
        elif self.motorConnection == client:
            print(&#39;Motor Pi isn\&#39;t supposed to send stuff&#39;)

        elif self.miniMotorConnection == client:
            print(&#39;Mini ROV isn\&#39;t supposed to send stuff&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerFactory</li>
<li>autobahn.twisted.websocket.WebSocketAdapterFactory</li>
<li>autobahn.websocket.protocol.WebSocketServerFactory</li>
<li>autobahn.websocket.protocol.WebSocketFactory</li>
<li>twisted.internet.protocol.ServerFactory</li>
<li>twisted.internet.protocol.Factory</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="code.core.server2020.ServerFactory.broadcast"><code class="name flex">
<span>def <span class="ident">broadcast</span></span>(<span>self, client, msg, isBinary)</span>
</code></dt>
<dd>
<section class="desc"><p>Broadcasts data to other connections.
This is how surface pi sends the
state of the XBox controller to motor pi</p>
<h2 id="arg">Arg</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<a title="code.core.server2020.ServerProtocol" href="#code.core.server2020.ServerProtocol"><code>ServerProtocol</code></a></dt>
<dd>The source of the message</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>str</code> or <code>bytes</code></dt>
<dd>The message to relay</dd>
<dt><strong><code>isBinary</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the msg is already encoded</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast(self, client, msg, isBinary):
    &#39;&#39;&#39;
    Broadcasts data to other connections.
    This is how surface pi sends the
    state of the XBox controller to motor pi

    Arg:
        client (ServerProtocol): The source of the message
        msg (str or bytes): The message to relay
        isBinary (bool): If the msg is already encoded
    &#39;&#39;&#39;

    # only surface pi is supposed to send data
    if self.surfaceConnection == client:

        # broadcast to motor2020
        if self.motorConnection:
            self.motorConnection.sendMessage(msg)

        # broadcast to miniROV
        if self.miniMotorConnection:
            self.miniMotorConnection.sendMessage(msg)

    # debug messages
    elif self.motorConnection == client:
        print(&#39;Motor Pi isn\&#39;t supposed to send stuff&#39;)

    elif self.miniMotorConnection == client:
        print(&#39;Mini ROV isn\&#39;t supposed to send stuff&#39;)</code></pre>
</details>
</dd>
<dt id="code.core.server2020.ServerFactory.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, client, clientTypeRequest)</span>
</code></dt>
<dd>
<section class="desc"><p>Called in <a title="code.core.server2020.ServerProtocol.onConnect" href="#code.core.server2020.ServerProtocol.onConnect"><code>ServerProtocol.onConnect()</code></a>
Remembers a connecting client so that
later data can be received from or broadcast to the client</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<a title="code.core.server2020.ServerProtocol" href="#code.core.server2020.ServerProtocol"><code>ServerProtocol</code></a></dt>
<dd>A instance representing the connection</dd>
<dt><strong><code>clientTypeRequest</code></strong> :&ensp;<code>str</code></dt>
<dd>Whether the client is surface or motor pi</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, client, clientTypeRequest):
    &#39;&#39;&#39;
    Called in `ServerProtocol.onConnect`
    Remembers a connecting client so that
    later data can be received from or broadcast to the client

    Args:
        client (ServerProtocol): A instance representing the connection
        clientTypeRequest (str): Whether the client is surface or motor pi
    &#39;&#39;&#39;

    if clientTypeRequest == &#39;surface&#39;:
        self.surfaceConnection = client  # surface sends joystick data

    elif clientTypeRequest == &#39;motor&#39;:
        self.motorConnection = client  # motor receives joystick data

    elif clientTypeRequest == &#39;miniROV&#39;:
        self.miniMotorConnection = client  # mini-rov recives joystick data

    else:
        print(&#39;Bad client type received: {}&#39;.format(clientTypeRequest))
        # end the connection because the client&#39;s type is not recognized
        # the type the client is is specified by the path in the url
        client._closeConnection()</code></pre>
</details>
</dd>
<dt id="code.core.server2020.ServerFactory.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, client)</span>
</code></dt>
<dd>
<section class="desc"><p>Called in <a title="code.core.server2020.ServerProtocol.onClose" href="#code.core.server2020.ServerProtocol.onClose"><code>ServerProtocol.onClose()</code></a>
Removes a client from the list of clients
as it is disconnecting from the server</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<a title="code.core.server2020.ServerProtocol" href="#code.core.server2020.ServerProtocol"><code>ServerProtocol</code></a></dt>
<dd>The connection to remove</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, client):
    &#39;&#39;&#39;
    Called in `ServerProtocol.onClose`
    Removes a client from the list of clients
    as it is disconnecting from the server

    Args:
        client (ServerProtocol): The connection to remove
    &#39;&#39;&#39;

    if self.surfaceConnection == client:
        self.surfaceConnection = None

    elif self.motorConnection == client:
        self.motorConnection = None

    elif self.miniMotorConnection == client:
        self.miniMotorConnection = None

    else:
        print(&#39;Unknown client: {}&#39;.format(client))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="code.core.server2020.ServerProtocol"><code class="flex name class">
<span>class <span class="ident">ServerProtocol</span></span>
</code></dt>
<dd>
<section class="desc"><p>Describes how the websocket server should act
with one connection</p>
<p>How to connect to it in JavaScript
ws = new WebSocket('ws://localhost:8008/motor')
ws = new WebSocket('ws://localhost:8008/surface')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerProtocol(WebSocketServerProtocol):
    &#39;&#39;&#39;
    Describes how the websocket server should act
    with one connection

    How to connect to it in JavaScript
    ws = new WebSocket(&#39;ws://localhost:8008/motor&#39;)
    ws = new WebSocket(&#39;ws://localhost:8008/surface&#39;)
    &#39;&#39;&#39;

    def onConnect(self, request):
        &#39;&#39;&#39;
        Called by the server factory when
        a client connects.
        The path is found in `request.path`
        and is used for the clients to specify
        whether they are motor2020 or surface2020
        &#39;&#39;&#39;

        print(request.path)
        # debug information
        print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
        clientTypeRequest = request.path

        # process the type of request
        if clientTypeRequest.startswith(&#39;/&#39;):
            # remove the slash if there is one
            clientTypeRequest = clientTypeRequest[1:]

        # tell the factory to remember the connection
        self.factory.register(self, clientTypeRequest)

    def onOpen(self):
        &#39;&#39;&#39;
        Called by the server factory.
        Only prints debug info
        &#39;&#39;&#39;
        print(&#39;WebSocket connection open&#39;)

    def onClose(self, wasClean, code, reason):
        &#39;&#39;&#39;
        Called by the server factory when
        a client disconnects
        &#39;&#39;&#39;
        print(&#39;WebSocket connection closed &amp; deregistering: {0}&#39;.format(reason))

        # tell the factory that this connection is dead
        self.factory.unregister(self)

    def onMessage(self, msg, isBinary):
        &#39;&#39;&#39;
        Called by the server factory when
        the client send a message.
        The message is then sent to all
        other connected clients
        &#39;&#39;&#39;

        # tell the factory to broadcast the received message
        # to all other connected clients
        self.factory.broadcast(self, msg, isBinary)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autobahn.twisted.websocket.WebSocketServerProtocol</li>
<li>autobahn.twisted.websocket.WebSocketAdapterProtocol</li>
<li>twisted.internet.protocol.Protocol</li>
<li>twisted.internet.protocol.BaseProtocol</li>
<li>autobahn.websocket.protocol.WebSocketServerProtocol</li>
<li>autobahn.websocket.protocol.WebSocketProtocol</li>
<li>autobahn.util.ObservableMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="code.core.server2020.ServerProtocol.onClose"><code class="name flex">
<span>def <span class="ident">onClose</span></span>(<span>self, wasClean, code, reason)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by the server factory when
a client disconnects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onClose(self, wasClean, code, reason):
    &#39;&#39;&#39;
    Called by the server factory when
    a client disconnects
    &#39;&#39;&#39;
    print(&#39;WebSocket connection closed &amp; deregistering: {0}&#39;.format(reason))

    # tell the factory that this connection is dead
    self.factory.unregister(self)</code></pre>
</details>
</dd>
<dt id="code.core.server2020.ServerProtocol.onConnect"><code class="name flex">
<span>def <span class="ident">onConnect</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by the server factory when
a client connects.
The path is found in <code>request.path</code>
and is used for the clients to specify
whether they are motor2020 or surface2020</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onConnect(self, request):
    &#39;&#39;&#39;
    Called by the server factory when
    a client connects.
    The path is found in `request.path`
    and is used for the clients to specify
    whether they are motor2020 or surface2020
    &#39;&#39;&#39;

    print(request.path)
    # debug information
    print(&#39;Client connecting &amp; registering: {0}&#39;.format(request.peer))
    clientTypeRequest = request.path

    # process the type of request
    if clientTypeRequest.startswith(&#39;/&#39;):
        # remove the slash if there is one
        clientTypeRequest = clientTypeRequest[1:]

    # tell the factory to remember the connection
    self.factory.register(self, clientTypeRequest)</code></pre>
</details>
</dd>
<dt id="code.core.server2020.ServerProtocol.onMessage"><code class="name flex">
<span>def <span class="ident">onMessage</span></span>(<span>self, msg, isBinary)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by the server factory when
the client send a message.
The message is then sent to all
other connected clients</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMessage(self, msg, isBinary):
    &#39;&#39;&#39;
    Called by the server factory when
    the client send a message.
    The message is then sent to all
    other connected clients
    &#39;&#39;&#39;

    # tell the factory to broadcast the received message
    # to all other connected clients
    self.factory.broadcast(self, msg, isBinary)</code></pre>
</details>
</dd>
<dt id="code.core.server2020.ServerProtocol.onOpen"><code class="name flex">
<span>def <span class="ident">onOpen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called by the server factory.
Only prints debug info</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onOpen(self):
    &#39;&#39;&#39;
    Called by the server factory.
    Only prints debug info
    &#39;&#39;&#39;
    print(&#39;WebSocket connection open&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="code.core" href="index.html">code.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="code.core.server2020.IP" href="#code.core.server2020.IP">IP</a></code></li>
<li><code><a title="code.core.server2020.PORT" href="#code.core.server2020.PORT">PORT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="code.core.server2020.ServerFactory" href="#code.core.server2020.ServerFactory">ServerFactory</a></code></h4>
<ul class="">
<li><code><a title="code.core.server2020.ServerFactory.broadcast" href="#code.core.server2020.ServerFactory.broadcast">broadcast</a></code></li>
<li><code><a title="code.core.server2020.ServerFactory.register" href="#code.core.server2020.ServerFactory.register">register</a></code></li>
<li><code><a title="code.core.server2020.ServerFactory.unregister" href="#code.core.server2020.ServerFactory.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code.core.server2020.ServerProtocol" href="#code.core.server2020.ServerProtocol">ServerProtocol</a></code></h4>
<ul class="">
<li><code><a title="code.core.server2020.ServerProtocol.onClose" href="#code.core.server2020.ServerProtocol.onClose">onClose</a></code></li>
<li><code><a title="code.core.server2020.ServerProtocol.onConnect" href="#code.core.server2020.ServerProtocol.onConnect">onConnect</a></code></li>
<li><code><a title="code.core.server2020.ServerProtocol.onMessage" href="#code.core.server2020.ServerProtocol.onMessage">onMessage</a></code></li>
<li><code><a title="code.core.server2020.ServerProtocol.onOpen" href="#code.core.server2020.ServerProtocol.onOpen">onOpen</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>